
/*
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 * 考位运算
 * 补码：一般表示负数，即将对应正数按位取反在+1，计算时是将（-最高位值+其余位的和)
 * &: 1&1=1, 1&0=0, 0&1=0, 0&0=0  技巧 n&1 可以判断奇偶
 * |: 1|1=1, 1|0=1, 0|1=1, 0|0=0 
 * ^: 1^1=0, 1^0=1, 0^0=0, 0^1=1  技巧 n^n=0  0^n=n
 * ~:取反
 *  注：位运算和乘法运算一样满足分配和交换律
 */
public class wei_yunsuan {
	public static void main(String[] args) {
		
	}
	//从n的2进制形式的最右边开始判断是不是1
    /*
    * 该解法如果输入时负数会陷入死循环，
    * 因为负数右移时，在最高位补得是1
    * 二本题最终目的是求1的个数，那么会有无数个
    * 1了。
    */
    //-------------可能陷入死循环的解法及优化---------------------
    public static int NumberOf1_CanNotUse(int n) {
        int count = 0;
        while (n != 0) {
            /*
            * 用1和n进行位与运算，
            * 结果要是为1则n的2进制形式
            * 最右边那位肯定是1，否则为0
            */
            if ((n & 1) == 1) {
                count++;
            }
            //把n的2进制形式往右推一位
//            n = n >> 1;  //负数陷入死循环
            n = n >>> 1;     //逻辑右移，无符号右移，左侧只用零填充
        }
        return count;
    }
	//---------------正解--------------------------------
    //思想：用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
    public static int NumberOf1_low(int n) {
        int count = 0;
        int flag = 1;
        while (flag != 0) {
            if ((n & flag) != 0) {
                count++;
            }
            flag = flag << 1;
        }
        return count;
    }
    //--------------------最优解----------------------------
    /*
     * 只要n!=0, n-1会让其位置第一个为1的数变为0，后面变为1，
     * 所以(n-1)&n 会让这个位置后面的数在重置为0,
     * 因此就相当于每次都挑出了n的一个1
     */
    public static int NumberOf1(int n) {
        int count = 0;
        while (n != 0) {
            ++count;
            n = (n - 1) & n;
        }
        return count;
    }
}
